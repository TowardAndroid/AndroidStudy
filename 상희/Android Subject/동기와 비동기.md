# 💡 동기와 비동기

# ✅ 동기와 비동기의 차이
동기(Synchronous)와 비동기(Asynchronous)는 프로그래밍에서 작업의 진행 방식을 나타내는 용어로, 작업이 어떻게 실행되고 완료되는지를 기준으로 구분된다.

<br/>

## 동기(Synchronous)
동기 방식은 작업이 순차적으로 실행되며, 이전 작업이 완료될 때까지 다음 작업이 실행되지 않는다.  
간단히 말하면 작업 A가 작업 B에 의존하고 있을 때, 작업 A가 완료되기 전까지 작업 B는 시작되지 않는다.  
작업이 블로킹되고 대기 상태에 들어갈 수 있다.

<br/>

## 비동기(Asynchronous)
비동기 방식은 작업이 동시에 실행되고, 이전 작업이 완료되기를 기다리지 않고 다음 작업을 진행한다.  
작업 간에 상호 의존성이 없다.  
작업이 블로킹되지 않고 계속 진행된다.

<br/>
<br/>

# ✅ 안드로이드에서의 비동기
## 비동기가 필요한 이유
Android는 UI thread라고 불리는 메인 스레드가 UI 작업을 관리하고 처리한다.  
UI thread는 사용자의 앱 사용성에 직결된 요소이기 때문에 항상 막힘없이 처리되어야 하는데, 만약 이 메인 스레드에서 네트워크나 DB로부터 자료를 받아오는 작업을 수행한다면 어플리케이션은 ANR(Application Not Responding) 상태가 될 것이다.  
따라서 비동기라는 개념이 중요하며, 여러 작업들을 각각의 스레드에 나눠서 Block 없이 수행할 수 있도록 설계해야 한다.

<br/>

## Android에서 비동기를 처리할 수 있는 방법
- Thread
    - Thread 클래스를 상속받아서 구현
    - Runnable 인터페이스를 구현하고 Thread 클래스를 사용해서 실행
- AsyncTask
    - API 30에서 Deprecated되었다.
    - Android 11부터 사용하지 않는다.
- RxJava
- RxKotlin
- Coroutine
- WorkManager

<br/>
<br/>

# ✅ 면접 질문
### Q1. 동기와 비동기에 대해 설명해 주세요.
동기(Synchronous)와 비동기(Asynchronous)는 프로그래밍에서 작업의 진행 방식을 나타내는 용어이다. 이들은 작업이 어떻게 실행되고 완료되는지를 기준으로 구분된다.  
- 동기(Synchronous)    
    : 동기 방식은 작업이 순차적으로 실행되며, 이전 작업이 완료될 때까지 다음 작업이 실행되지 않는다.     
    간단히 말해, 작업 A가 작업 B에 의존하고 있을 때, 작업 A가 완료되기 전까지 작업 B는 시작되지 않는다.     
    작업이 블로킹되고 대기 상태에 들어갈 수 있다.
    
- 비동기(Asynchronous)    
    : 비동기 방식은 작업이 동시에 실행되고, 이전 작업이 완료되기를 기다리지 않고 다음 작업을 진행한다.     
    작업 간에 상호 의존성이 없다.     
    작업이 블로킹되지 않고 계속 진행된다.
    
<br/>

### Q2. 블로킹과 넌블로킹에 대해 설명해 주세요.
블로킹(Blocking)과 넌블로킹(Non-blocking)은 작업을 어떻게 처리하는지를 나타내는 용어로, 주로 입출력(IO) 작업과 관련된다.  
- 블로킹(Blocking)    
    : 블로킹 작업은 호출된 함수 또는 작업이 완료될 때까지 현재 실행 흐름이 멈추는 것을 의미한다.    
    예를 들어, 파일을 읽을 때 블로킹 작업을 수행하면 파일이 완전히 읽혀질 때까지 다음 코드는 실행되지 않는다.    
    블로킹 작업을 수행하는 동안은 대기 상태에 있을 수 있다.
    
- 넌블로킹(Non-blocking)    
    : 넌블로킹 작업은 호출된 함수 또는 작업이 즉시 반환되며, 현재 실행 흐름이 멈추지 않고 계속 진행된다.    
    예를 들어, 파일을 비동기적으로 읽을 때 넌블로킹 작업을 수행하면 파일 읽기 요청 후 즉시 반환되며, 나중에 완료될 때 알림을 받을 수 있다.    
    넌블로킹 작업을 수행하는 동안 다른 작업을 수행할 수 있다.

<br/>    

### Q3. 다른 비동기 처리 라이브러리 말고 Coroutine을 사용하는 이유는 무엇일까요?
Coroutine은 비동기 처리를 위한 강력하고 유연한 도구이다. Coroutine은 다른 비동기 처리 라이브러리와 비교하여 몇 가지 이점을 가지고 있다.  
- 가독성    
    : Coroutine은 동기 코드와 유사한 구문을 사용하여 비동기 작업을 표현할 수 있다. 이는 코드의 가독성을 향상시키고, 비동기 작업의 흐름을 이해하기 쉽게 만든다. 콜백 함수를 사용하는 기존의 비동기 처리 방식에 비해 코드의 복잡성을 줄일 수 있다.    
- 순차적인 코드 작성    
    : Coroutine을 사용하면 순차적인 코드로 비동기 작업을 작성할 수 있다. 즉, 비동기 작업을 여러 단계로 나누고 각 단계를 순차적으로 실행할 수 있다. 이는 코드의 로직을 이해하기 쉽게 만들어주며, 에러 처리와 제어 흐름을 단순화할 수 있다.    
- 상태 유지    
    : Coroutine은 상태를 유지할 수 있다. 이는 비동기 작업이 여러 단계에 걸쳐 이루어져야 하는 경우 매우 유용하다. Coroutine은 각 단계에서 상태를 저장하고 다음 단계에서 이어서 실행할 수 있다. 이를 통해 비동기 작업의 일시 중지와 재개가 가능하며, 작업을 유지하면서도 코드를 단순화할 수 있다.    
- 에러 처리    
    : Coroutine은 예외 처리를 간편하게 만든다. 일반적인 동기 코드와 마찬가지로 try-catch 구문을 사용하여 예외를 처리할 수 있다. 또한 Coroutine은 예외 처리를 작업의 단계별로 구성할 수 있어 디버깅과 오류 처리를 용이하게 한다.    
- 확장성    
    : Coroutine은 일반적인 비동기 작업 이외에도 다양한 동시성 작업에 유용하다. 여러 개의 비동기 작업을 병렬로 실행하거나, 동기화를 필요로 하는 작업을 순차적으로 실행하는 등 다양한 동시성 패턴을 지원한다.
    
<br/>
<br/>

# 🗂 참고
- [안드로이드 개발자 기술 면접 중 나왔던 질문 정리 (velog.io)](https://velog.io/@godmin66/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%A9%B4%EC%A0%91-%EC%A4%91-%EB%82%98%EC%99%94%EB%8D%98-%EC%A7%88%EB%AC%B8-%EB%AA%A9%EB%A1%9D)
- [[Android] 비동기 처리 (velog.io)](https://velog.io/@paulus0617/Android-async)
- [[Kotlin/Android] 비동기 처리 (Asynchronous Programming) | by dev.jihun | 프로그래머-빵지 | Medium](https://medium.com/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-%EB%B9%B5%EC%A7%80/kotlin-android-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC-acd8902937e5)
- [[Kotlin/Android] 비동기 처리 방법 (AsyncTask, RxKotlin, Coroutines) | by dev.jihun | 프로그래머-빵지 | Medium](https://medium.com/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-%EB%B9%B5%EC%A7%80/kotlin-android-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC-%EB%B0%A9%EB%B2%95-asynctask-rxkotlin-coroutine-4ad90b8f653e)
